# Многопоточность в Java

## 1. Основы Java. Классы и интерфейсы. Наследование

### Задание: 

Cоздать Java-приложение, выводящее сообщение:

	Hello world!!! Hello <имя>!!!

где <имя> - имя, передаваемое приложению в качестве параметра.

### Материалы для изучения:

https://www.w3schools.com/java/default.asp

https://www.tutorialspoint.com/java/index.htm

https://habr.com/ru/post/125210/

https://docs.oracle.com/javase/tutorial/


## 2. Многопоточность в Java.

### Задание:

Cоздать приложение, выводящее в одном потоке слово "Hello", а в другом " world". Запустить приложение несколько раз. Для более сбалансированного эффекта можно добавить
в каждый из потоков небольшую задержку:

	Thread.sleep(100);

### Материалы для изучения:

https://tproger.ru/translations/java8-concurrency-tutorial-1/


## 3. Многопоточное приложение - вариант 1-ый

### Задание:

Создать приложение для вычисления в k потоков суммы функции натурального аргумента на натуральном отрезке от [m, n]. Распараллеливание осуществить по принципу исходного разделения отрезка между потоками на примерно равные части. В результате работы программы вывести результат и время выполнения вычислений в миллисекундах. Для абстракции вычисления функции натурального аргумента создать соответствующий интерфейс. Для реальныхх вычислений испольозвать реалиацию этого интерфейса - класс для вычисления является ли данное натуральное число простым. Для определения этого использовать алгоритм перебора до квадратного корня из числа. 

### Указания:

Познакомьтесь с интерфейсом Runnable и классом Thread. Изучите назначение ключевых слов volatile и synchronized и воспользуйтесь ими при реализации накопления суммы. Для ожидания заверешения всех вычислительных потоков из основного воспользуйтесь методом join:

https://docs.oracle.com/javase/tutorial/essential/concurrency/join.html

Отметьте время выполнения вычислений для вычислений в 1 поток, в 2 потока, 3 потока и т.д. Заметьте, что, начиная с некоторого количества потоков, перестаёт наблюдаться прирост производительности. Отметьте также непропорциональный характер уменьшения времени работы с увеличением количества потоков и объясните его причину.

### Материалы для изучения:

https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html

https://habr.com/ru/company/luxoft/blog/157273/

http://tutorials.jenkov.com/java-concurrency/index.html

https://habr.com/ru/post/108016/


## 4. Многопоточное приложение - вариант 2-ой

### Задание:

Улучшить предыдущую программу за счёт разбиения отрезка на небольшие подотрезки (оптимальную величину подотрезка необходимо вычислить экспериментально). Принцип организации вычислений в потоках должен быть следующий: изначально запускается k потоков. После окончания вычисления в потоке и фиксации результата происходит создание нового потока для обработки очередного необработанного подотрезки. 

Убедиться в неправильности произведения вычислений при отсутствии синхронизации метода фиксации результата потоками.

Произвести замеры времени работы программы. Убедиться в пропорциональности характера уменьшения времени работы с увеличением количества потоков для небольшого количества потоков. Убедиться в превышении общего времени вычислений аналогичных показателей предыдущего варианта решения задачи. Объяснить причину.

### Указания:

Познакомьтесь с синхронизированным вариантом списка:

https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#synchronizedList(java.util.List)

и воспользуйтесь им для безопасного добавления новых поток в общий список.


## 5. Многопоточное приложение - вариант 3-ий

Реализовать третий вариант решения задачи - после завершния обработки очередного подотрезки поток не завершает свою работу, а запрашивает у управляющего процессом класса очередной подотрезок, новые потоки после создания исходных k вычислительных потоков не создаются. Убедиться в оптимальности этого подхода среди всех рассмотренных.
